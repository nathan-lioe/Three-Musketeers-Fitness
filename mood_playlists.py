import vertexai
from vertexai.generative_models import GenerativeModel
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import random
import re
import streamlit as st

# Initialize Vertex AI
vertexai.init(project="genial-venture-454302-f9", location="us-central1")
model = GenerativeModel("gemini-1.5-flash-002")

# Set up Spotify client
sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(client_id="9ac50b241ba74c3e9abb14cdf33c3efa", client_secret="24eefa94bebe42fcbd45d8e0d7aa181c"))


# Function to get the mood from the select box
def get_mood(selected_mood=None):
    """
    Returns the selected mood or defaults to 'happy' if none is selected.
    
    Args:
        selected_mood (str, optional): The mood selected by the user. Defaults to None.
        
    Returns:
        str: The mood to use for playlist generation
    """
    valid_moods = ["happy", "sad", "relaxed", "energetic"]
    
    if selected_mood in valid_moods:
        return selected_mood
    else:
        return "happy"  # Default mood

# Determine speed category based on speed input
def get_speed_category(speed):
    if speed < 4:
        return "low"
    elif speed < 8:
        return "medium"
    else:
        return "high"

# Embed Spotify playlist
def embed_spotify_player(playlist_id):
    spotify_url = f"https://open.spotify.com/embed/playlist/{playlist_id}"
    st.markdown(
        f'<iframe src="{spotify_url}" width="500" height="380" '
        f'frameBorder="0" allow="encrypted-media" '
        f'style="border-radius: 10px;"></iframe>',
        unsafe_allow_html=True
    )

# Use Vertex AI to generate a playlist description
def get_vertex_playlist_description(mood, speed_category):
    """
    Generates a music playlist description based on the given mood and speed category
    using the Vertex AI Gemini model.
    """
    prompt = f"""You are a creative and engaging music expert. 
    Suggest a playlist description for someone feeling {mood} and wanting a {speed_category} paced vibe. 
    Make it sound exciting and mood-appropriate in 1â€“2 sentences."""
    
    response = model.generate_content(prompt)
    return response.text.strip()

# Generate AI playlist recommendation with songs
def get_vertex_playlist(mood, speed_category):
    """
    Generates a music playlist recommendation based on the given mood and speed category
    using the Vertex AI Gemini model.
    """
    prompt = f"""You are a creative and engaging music expert. 
    Create a custom playlist of 5-8 song recommendations for someone feeling {mood} and wanting a {speed_category} paced vibe.
    For each song, include the title, artist, and a very brief comment about why it fits the mood.
    Format the output as a markdown list."""
    
    response = model.generate_content(prompt)
    return response.text.strip()

def validate_spotify_playlist_id(playlist_id):
    """
    Validates whether the playlist ID exists on Spotify by querying the API.
    """
    try:
        # Try to fetch the playlist using the Spotify API
        playlist = sp.playlist(playlist_id)
        return playlist is not None
    except spotipy.exceptions.SpotifyException:
        # If an error occurs (e.g., playlist not found), return False
        return False

def get_ai_spotify_playlist(mood, speed_category):
    """
    Generates a Spotify playlist ID based on mood and speed category
    using Vertex AI Gemini model, with a fallback if AI generates an invalid ID.
    """
    prompt = f"""
    You are a music expert working at Spotify.
    A user is feeling '{mood}' and wants music with a '{speed_category}' tempo.
    Provide exactly ONE real, active Spotify playlist ID (22 characters long, alphanumeric string).
    The ID should be from a playlist that is currently available on Spotify. 
    Do NOT include any other text, explanation, or any invalid playlist IDs.
    Provide only the ID itself, such as: 37i9dQZF1DX76Wlfdnj7AP.
    """

    try:
        # Generate playlist ID using AI
        response = model.generate_content(prompt)
        playlist_raw = response.text.strip()

        # Extract valid 22-character alphanumeric ID
        match = re.search(r"\b([A-Za-z0-9]{22})\b", playlist_raw)
        if match:
            generated_playlist_id = match.group(1)
            
            # Validate the generated playlist ID
            if validate_spotify_playlist_id(generated_playlist_id):
                return generated_playlist_id
            else:
                st.warning(f"Generated playlist ID {generated_playlist_id} is invalid. Falling back to sample.")
                raise ValueError("Invalid playlist ID generated by AI.")  # Explicit error to trigger fallback
        else:
            st.warning("No valid playlist ID generated by AI. Falling back to sample playlist ID.")
            raise ValueError("Invalid playlist ID format generated by AI.")  # Explicit error to trigger fallback

    except Exception as e:
        # Log the error and fall back to predefined sample IDs
        st.warning(f"Error generating or validating playlist ID: {e} Using fallback.")

        # Predefined sample playlist IDs based on mood and speed
        sample_playlists = {
            "happy": {
                "low": "37i9dQZF1DX6VdMW310YC7",
                "medium": "37i9dQZF1DXdPec7aLTmlC",
                "high": "37i9dQZF1DWZgauS5j6pMv"
            },
            "sad": {
                "low": "37i9dQZF1DX7qK8ma5wgG1",
                "medium": "37i9dQZF1DWVrtsSlLKzro",
                "high": "37i9dQZF1DWZUAeYvs88zc"
            },
            "relaxed": {
                "low": "37i9dQZF1DX8Uebhn9wzrS",
                "medium": "37i9dQZF1DX4WYpdgoIcn6",
                "high": "37i9dQZF1DX9uKNf5jGX6m"
            },
            "energetic": {
                "low": "37i9dQZF1DX0hWmn8d5pRe",
                "medium": "37i9dQZF1DX76Wlfdnj7AP",
                "high": "37i9dQZF1DX4eRPd9frC1m"
            }
        }

        # Get the fallback playlist ID from the sample list based on the mood and speed category
        fallback_playlist_id = sample_playlists.get(mood, sample_playlists["happy"]).get(speed_category, sample_playlists["happy"]["medium"])
        
        return fallback_playlist_id